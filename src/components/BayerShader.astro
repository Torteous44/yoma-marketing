---
interface Props {
    color?: string;
    pixelSize?: number;
    fadeDirection?: "top" | "left";
}

const { color = "#0a0a0a", pixelSize = 4, fadeDirection = "top" } = Astro.props;
---

<canvas id="bayerCanvas"></canvas>

<style>
    #bayerCanvas {
        will-change: transform;
        transform: translateZ(0);
        display: block;
        width: 100%;
        height: 100%;
    }
</style>

<script define:vars={{ color, pixelSize, fadeDirection }}>
    const canvas = document.getElementById("bayerCanvas");
    const gl = canvas.getContext("webgl2", {
        alpha: true,
        premultipliedAlpha: false,
        antialias: false,
        powerPreference: "high-performance",
        desynchronized: true,
    });

    if (!gl) {
        console.error("WebGL2 not supported");
    } else {
        // Vertex shader
        const vertexShaderSource = `#version 300 es
      in vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

        // Fragment shader
        const fragmentShaderSource = `#version 300 es
      precision highp float;

      uniform vec3  uColor;
      uniform vec2  uResolution;
      uniform vec4  uMouse;
      uniform float uTime;
      uniform float uPixelSize;
      uniform int   uShapeType;
      uniform int   uFadeDirection;

      const int SHAPE_SQUARE   = 0;
      const int SHAPE_CIRCLE   = 1;
      const int SHAPE_TRIANGLE = 2;
      const int SHAPE_DIAMOND  = 3;

      const int   MAX_CLICKS = 10;
      uniform vec2  uClickPos  [MAX_CLICKS];
      uniform float uClickTimes[MAX_CLICKS];

      out vec4 fragColor;

      float Bayer2(vec2 a) {
        a = floor(a);
        return fract(a.x / 2. + a.y * a.y * .75);
      }

      #define Bayer4(a) (Bayer2(.5*(a))*0.25 + Bayer2(a))
      #define Bayer8(a) (Bayer4(.5*(a))*0.25 + Bayer2(a))

      #define FBM_OCTAVES     5
      #define FBM_LACUNARITY  1.25
      #define FBM_GAIN        1.
      #define FBM_SCALE       4.0

      float hash11(float n) { return fract(sin(n)*43758.5453); }

      float vnoise(vec3 p) {
        vec3 ip = floor(p);
        vec3 fp = fract(p);

        float n000 = hash11(dot(ip + vec3(0.0,0.0,0.0), vec3(1.0,57.0,113.0)));
        float n100 = hash11(dot(ip + vec3(1.0,0.0,0.0), vec3(1.0,57.0,113.0)));
        float n010 = hash11(dot(ip + vec3(0.0,1.0,0.0), vec3(1.0,57.0,113.0)));
        float n110 = hash11(dot(ip + vec3(1.0,1.0,0.0), vec3(1.0,57.0,113.0)));
        float n001 = hash11(dot(ip + vec3(0.0,0.0,1.0), vec3(1.0,57.0,113.0)));
        float n101 = hash11(dot(ip + vec3(1.0,0.0,1.0), vec3(1.0,57.0,113.0)));
        float n011 = hash11(dot(ip + vec3(0.0,1.0,1.0), vec3(1.0,57.0,113.0)));
        float n111 = hash11(dot(ip + vec3(1.0,1.0,1.0), vec3(1.0,57.0,113.0)));

        vec3 w = fp*fp*fp*(fp*(fp*6.0-15.0)+10.0);

        float x00 = mix(n000, n100, w.x);
        float x10 = mix(n010, n110, w.x);
        float x01 = mix(n001, n101, w.x);
        float x11 = mix(n011, n111, w.x);

        float y0  = mix(x00, x10, w.y);
        float y1  = mix(x01, x11, w.y);

        return mix(y0, y1, w.z) * 2.0 - 1.0;
      }

      float fbm2(vec2 uv, float t) {
        vec3 p   = vec3(uv * FBM_SCALE, t);
        float amp  = 1.;
        float freq = 1.;
        float sum  = 1.;

        for (int i = 0; i < FBM_OCTAVES; ++i) {
          sum  += amp * vnoise(p * freq);
          freq *= FBM_LACUNARITY;
          amp  *= FBM_GAIN;
        }

        return sum * 0.5 + 0.5;
      }

      float maskSquare(vec2 p, float cov) {
        vec2 d = abs(p - 0.5);
        float maxDist = sqrt(cov) * 0.5;
        return step(max(d.x, d.y), maxDist);
      }

      void main() {
        float pixelSize = uPixelSize;
        vec2 fragCoord = gl_FragCoord.xy - uResolution * .5;

        float aspectRatio = uResolution.x / uResolution.y;

        vec2 pixelId = floor(fragCoord / pixelSize);
        vec2 pixelUV = fract(fragCoord / pixelSize);

        float cellPixelSize =  8. * pixelSize;
        vec2 cellId = floor(fragCoord / cellPixelSize);
        vec2 cellCoord = cellId * cellPixelSize;
        vec2 uv = cellCoord / uResolution * vec2(aspectRatio, 1.0);

        // Add offset to change the noise pattern distribution
        float feed = fbm2(uv + vec2(80.0, 50.0), uTime * 0.05);
        feed = feed * 0.5 - 0.65;

        const float speed     = 0.90;
        const float thickness = 0.10;
        const float dampT     = 5.0;
        const float dampR     = 9.0;

        for (int i = 0; i < MAX_CLICKS; ++i) {
          vec2 pos = uClickPos[i];
          if (pos.x < 0.0) continue;

          vec2 cuv = (((pos - uResolution * .5 - cellPixelSize * .5) / (uResolution) )) * vec2(aspectRatio, 1.0);

          float t = max(uTime - uClickTimes[i], 0.0);
          float r = distance(uv, cuv);

          float waveR = speed * t;
          float ring  = exp(-pow((r - waveR) / thickness, 2.0));
          float atten = exp(-dampT * t) * exp(-dampR * r);
          feed = max(feed, ring * atten);
        }

        float bayer = Bayer8(fragCoord / uPixelSize) - 0.5;
        float bw    = step(0.5, feed + bayer);

        float coverage = bw;
        float M = maskSquare(pixelUV, coverage);

        // Natural fall-off (direction depends on uFadeDirection: 0 = top, 1 = left)
        float fade;
        if (uFadeDirection == 1) {
          // Fade from left
          float normalizedX = gl_FragCoord.x / uResolution.x;
          float fadeDistance = 1.8;
          fade = smoothstep(0.0, fadeDistance, normalizedX);
        } else {
          // Fade from top
          float normalizedY = gl_FragCoord.y / uResolution.y;
          float fadeDistance = 1.0;
          fade = 1.0 - smoothstep(1.0 - fadeDistance, 1.0, normalizedY);
        }

        M *= fade;

        vec3 color = uColor;
        fragColor = vec4(color, M);
      }
    `;

        // Compile shader
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(
                    "Shader compile error:",
                    gl.getShaderInfoLog(shader),
                );
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(
            gl,
            vertexShaderSource,
            gl.VERTEX_SHADER,
        );
        const fragmentShader = compileShader(
            gl,
            fragmentShaderSource,
            gl.FRAGMENT_SHADER,
        );

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error("Program link error:", gl.getProgramInfoLog(program));
        }

        // Set up geometry (full-screen quad)
        const positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, "a_position");

        // Get uniform locations
        const uColorLoc = gl.getUniformLocation(program, "uColor");
        const uResolutionLoc = gl.getUniformLocation(program, "uResolution");
        const uMouseLoc = gl.getUniformLocation(program, "uMouse");
        const uTimeLoc = gl.getUniformLocation(program, "uTime");
        const uPixelSizeLoc = gl.getUniformLocation(program, "uPixelSize");
        const uShapeTypeLoc = gl.getUniformLocation(program, "uShapeType");
        const uFadeDirectionLoc = gl.getUniformLocation(
            program,
            "uFadeDirection",
        );
        const uClickPosLoc = gl.getUniformLocation(program, "uClickPos");
        const uClickTimesLoc = gl.getUniformLocation(program, "uClickTimes");

        // Parse color
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
                hex,
            );
            return result
                ? [
                      parseInt(result[1], 16) / 255,
                      parseInt(result[2], 16) / 255,
                      parseInt(result[3], 16) / 255,
                  ]
                : [0, 0, 0];
        }

        const rgbColor = hexToRgb(color);

        // Click tracking
        const MAX_CLICKS = 10;
        const clicks = Array(MAX_CLICKS)
            .fill(null)
            .map(() => ({ x: -1, y: -1, time: 0 }));
        let clickIndex = 0;

        canvas.addEventListener(
            "click",
            (e) => {
                const rect = canvas.getBoundingClientRect();
                const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
                clicks[clickIndex] = {
                    x: (e.clientX - rect.left) * dpr,
                    y: (rect.height - (e.clientY - rect.top)) * dpr,
                    time: performance.now() / 1000,
                };
                clickIndex = (clickIndex + 1) % MAX_CLICKS;
            },
            { passive: true },
        );

        // Stable resize handler
        const DPR_CAP = 2;
        let lastW = 0,
            lastH = 0;

        function resize() {
            const dpr = Math.min(window.devicePixelRatio || 1, DPR_CAP);
            const cssW = Math.round(canvas.clientWidth);
            const cssH = Math.round(canvas.clientHeight);
            const w = Math.round(cssW * dpr);
            const h = Math.round(cssH * dpr);

            if (w !== lastW || h !== lastH) {
                lastW = w;
                lastH = h;
                canvas.width = w;
                canvas.height = h;
                gl.viewport(0, 0, w, h);
            }
        }

        let rafResize = 0;
        const queueResize = () => {
            if (!rafResize)
                rafResize = requestAnimationFrame(() => {
                    rafResize = 0;
                    resize();
                });
        };

        window.addEventListener("resize", queueResize, { passive: true });

        // Wait for layout to complete before initial resize
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                resize();
            });
        });

        // Render loop
        function render(time) {
            time *= 0.001; // Convert to seconds

            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            gl.enableVertexAttribArray(positionLocation);
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            // Set uniforms
            gl.uniform3fv(uColorLoc, rgbColor);
            gl.uniform2f(uResolutionLoc, canvas.width, canvas.height);
            gl.uniform4f(uMouseLoc, 0, 0, 0, 0);
            gl.uniform1f(uTimeLoc, time);
            gl.uniform1f(uPixelSizeLoc, pixelSize);
            gl.uniform1i(uShapeTypeLoc, 3); // SHAPE_DIAMOND
            gl.uniform1i(uFadeDirectionLoc, fadeDirection === "left" ? 1 : 0);

            // Set click uniforms
            const clickPositions = new Float32Array(MAX_CLICKS * 2);
            const clickTimes = new Float32Array(MAX_CLICKS);

            for (let i = 0; i < MAX_CLICKS; i++) {
                clickPositions[i * 2] = clicks[i].x;
                clickPositions[i * 2 + 1] = clicks[i].y;
                clickTimes[i] = clicks[i].time;
            }

            gl.uniform2fv(uClickPosLoc, clickPositions);
            gl.uniform1fv(uClickTimesLoc, clickTimes);

            // Enable blending for alpha
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);
    }
</script>
